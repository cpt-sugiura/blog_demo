<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8"/>
  <title>タイム差シミュレーション(複数セット比較対応)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
      /* レイアウト調整 */
      #calc-form {
          display: grid;
          grid-template-columns: repeat(12, fit-content(100%));
          width: 100%;
          gap: 10px;
      }

      #calc-form label {
          justify-self: end;
      }

      #calc-form button,
      #calc-form table {
          grid-column: span 12;
      }

      #calc-form table {
          border-collapse: collapse;
          border: 1px solid black;
      }

      #calc-form th,
      #calc-form td {
          border: 1px solid black;
          padding: 4px;
      }

      #calc-form button,
      #calc-form input,
      #calc-form select {
          width: 100%;
          box-sizing: border-box;
      }

      .skill-table thead th {
          background: #f0f0f0;
      }

      .skill-table caption {
          font-weight: bold;
      }

      label:has(input[type="checkbox"]) {
        display: inline-flex;
        align-items: center;
      }

      /* 統合テーブルのスタイル */
      #rangeTableCombined {
        width: 100%;
        border-collapse: collapse;
        text-align: center;
        margin-top: 1rem;
      }
      #rangeTableCombined th {
        background: #f0f0f0;
      }
  </style>
</head>
<body>
<!-- フォーム -->
<form id="calc-form">
  <label for="courseLength">コース長</label>
  <input type="number" id="courseLength" value="1200"/>

  <label for="baseMidSpeed">素の中盤最高速度</label>
  <input type="number" id="baseMidSpeed" value="16" step="0.01"/>

  <label for="baseFinalSpeed">素の終盤最高速度</label>
  <input type="number" id="baseFinalSpeed" value="20" step="0.01"/>

  <label for="baseAccel">素の加速度</label>
  <input type="number" id="baseAccel" value="0.5" step="0.01"/>

  <label for="skillRate">スキル発動率</label>
  <input type="number" id="skillRate" value="0.3" min="0" max="1" step="0.001"/>

  <label for="trials">試行回数</label>
  <input type="number" id="trials" value="10000"/>

  <table class="skill-table">
    <caption>スキル一覧</caption>
    <thead>
      <tr>
        <th>スキル名</th>
        <th>発動区間(開始)</th>
        <th>発動区間(終了)</th>
        <th>素の持続時間</th>
        <th>最高速度+ (上乗せ)</th>
        <th>加速度+ (上乗せ)</th>
        <th>現在速度+ (上乗せ)</th>
        <th>個別発動確率</th>
        <th>セットA/B</th>
        <th>操作</th>
      </tr>
    </thead>
    <tbody id="skillTableBody">
      <!-- 初期行(1行) -->
      <tr data-idx="0">
        <td><input type="text" class="skill-name" placeholder="スキル名" value="スキル例"/></td>
        <td><input type="number" class="skill-start" placeholder="開始m" value="200" step="0.01"/></td>
        <td><input type="number" class="skill-end" placeholder="終了m" value="400" step="0.01"/></td>
        <td><input type="number" class="skill-base-duration" placeholder="秒" value="3" step="0.01"/></td>
        <td><input type="number" class="skill-top-speed-bonus" placeholder="+最高速" value="2" step="0.01"/></td>
        <td><input type="number" class="skill-accel-bonus" placeholder="+加速度" value="1" step="0.01"/></td>
        <td><input type="number" class="skill-current-speed-bonus" placeholder="+現在速" value="0" step="0.01"/></td>
        <td><input type="number" class="skill-individual-rate" placeholder="確率(0-1)" step="0.001"/></td>
        <td>
          <label><input type="checkbox" class="set-a" checked>A</label>
          <label><input type="checkbox" class="set-b" checked>B</label>
        </td>
        <td>
          <button type="button" class="delete-row">削除</button>
        </td>
      </tr>
      <tr>
        <td colspan="10">
          <button type="button" id="addSkillRow">スキル追加</button>
        </td>
      </tr>
    </tbody>
  </table>

  <button type="submit">計算する</button>
</form>

<!-- グラフ -->
<canvas id="timeDiffChart" width="800" height="400"></canvas>

<!-- A/B で揃えたテーブル -->
<h3>累積度数範囲ごとの最大秒数差分(A/B)</h3>
<table id="rangeTableCombined" border="1">
  <thead>
    <tr>
      <th>累積度数範囲</th>
      <th>最大秒数差分(A)</th>
      <th>距離(Aの最大秒数差 × 終盤速度)</th>
      <th>最大秒数差分(B)</th>
      <th>距離(Bの最大秒数差 × 終盤速度)</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<script>
/**
 * ローカルストレージキー
 */
const STORAGE_KEY = 'timeSimulationFormData';

/**
 * 「スキルなし」での走破タイムを計算する関数
 *  - ゴール手前で部分的に dt を調整して、離散的にならないようにする
 */
function runNoSkill(courseLength, baseMidSpeed, baseFinalSpeed, baseAccel) {
  const dt = 0.0166667; // (1/60)秒を基本ステップにする例
  let time = 0;
  let distance = 0;
  let currentSpeed = 0;

  const midPoint = (2 / 3) * courseLength;

  while (true) {
    // 中盤か終盤か判定
    const isFinal = distance >= midPoint;
    const topSpeed = isFinal ? baseFinalSpeed : baseMidSpeed;

    // 加速
    currentSpeed += baseAccel * dt;
    if (currentSpeed > topSpeed) {
      currentSpeed = topSpeed;
    }

    // 次のステップでゴールを越えるか判定
    const nextDist = distance + currentSpeed * dt;
    if (nextDist >= courseLength) {
      // ゴール手前分を線形に計算して終了
      const remain = courseLength - distance;
      const partialDt = remain / currentSpeed;
      time += partialDt;
      distance = courseLength;
      break;
    } else {
      distance = nextDist;
      time += dt;
    }

    if (distance >= courseLength) {
      break;
    }
  }

  return time;
}

/**
 * 「スキルあり」での走破タイムを計算する関数
 *  - runNoSkill 同様、ゴール直前だけ部分的に dt を小さくして線形計算
 */
function runWithSkill(courseLength, baseMidSpeed, baseFinalSpeed, baseAccel, skillRate, skills) {
  // どのスキルが発動するか判定
  const activeSkills = [];
  skills.forEach((skill) => {
    if (shouldActivateSkill(skillRate, skill.individualRate)) {
      // ランダムな位置で発動 (発動開始～終了距離の間)
      const triggerPoint = skill.start + (skill.end - skill.start) * Math.random();
      // 持続時間はコース長に応じてスケーリングする例 (適宜調整)
      const actualDuration = skill.baseDuration * (courseLength / 1000);
      activeSkills.push({
        name: skill.name,
        startDistance: triggerPoint,
        duration: actualDuration,
        topSpeedBonus: skill.topSpeedBonus,
        accelBonus: skill.accelBonus,
        currentSpeedBonus: skill.currentSpeedBonus,
      });
    }
  });

  // 距離->時刻テーブルを作る(スキルなし) => 発動開始時刻計算のため
  const dt = 0.0166667; // (1/60)秒
  const distanceToTimeMap = [];
  {
    let tmpTime = 0;
    let tmpDist = 0;
    let tmpSpeed = 0;
    const midPoint = (2 / 3) * courseLength;

    while (tmpDist < courseLength) {
      const isFinal = tmpDist >= midPoint;
      const topSpeed = isFinal ? baseFinalSpeed : baseMidSpeed;

      tmpSpeed += baseAccel * dt;
      if (tmpSpeed > topSpeed) {
        tmpSpeed = topSpeed;
      }
      const nextDist = tmpDist + tmpSpeed * dt;
      tmpTime += dt;
      tmpDist = nextDist;
      distanceToTimeMap.push({ dist: tmpDist, time: tmpTime });
      if (tmpDist >= courseLength) break;
    }
  }

  // 距離->時刻を返す補助関数
  function getTimeByDistance(d) {
    for (let i = 0; i < distanceToTimeMap.length; i++) {
      if (distanceToTimeMap[i].dist >= d) {
        return distanceToTimeMap[i].time;
      }
    }
    return distanceToTimeMap[distanceToTimeMap.length - 1].time;
  }

  // 発動開始時刻と終了時刻を付与
  activeSkills.forEach((sk) => {
    const startTime = getTimeByDistance(sk.startDistance);
    sk.startTime = startTime;
    sk.endTime = startTime + sk.duration;
  });

  // 実際の走行シミュレーション (スキルあり)
  let time = 0;
  let distance = 0;
  let currentSpeed = 0;
  const midPoint2 = (2 / 3) * courseLength;

  while (true) {
    // いま時刻で発動中のスキルボーナス合算
    let activeTopSpeedBonus = 0;
    let activeAccelBonus = 0;
    let activeCurrentSpeedBonus = 0;

    activeSkills.forEach((sk) => {
      if (sk.startTime <= time && time < sk.endTime) {
        activeTopSpeedBonus += sk.topSpeedBonus;
        activeAccelBonus += sk.accelBonus;
        activeCurrentSpeedBonus += sk.currentSpeedBonus;
      }
    });

    // 中盤 or 終盤判定
    const isFinal = distance >= midPoint2;
    const baseTopSpeed = isFinal ? baseFinalSpeed : baseMidSpeed;
    const topSpeed = baseTopSpeed + activeTopSpeedBonus;

    // 加速
    currentSpeed += (baseAccel + activeAccelBonus) * dt;
    if (currentSpeed > topSpeed) {
      currentSpeed = topSpeed;
    }

    // currentSpeedBonus はフレームごとの加算として扱う例
    currentSpeed += activeCurrentSpeedBonus * dt;

    // 次フレームでゴール越え判定
    const nextDist = distance + currentSpeed * dt;
    if (nextDist >= courseLength) {
      const remain = courseLength - distance;
      const partialDt = remain / currentSpeed;
      time += partialDt;
      distance = courseLength;
      break;
    } else {
      distance = nextDist;
      time += dt;
    }

    if (distance >= courseLength) {
      break;
    }
  }

  return time;
}

/**
 * スキル発動判定 (個別確率が設定されていれば個別優先、それ以外はグローバルなスキル発動率)
 */
function shouldActivateSkill(globalRate, individualRate) {
  const rate = (individualRate != null && !Number.isNaN(individualRate))
    ? individualRate
    : globalRate;
  return Math.random() < rate;
}

/**
 * フォーム入力をまとめて取得する
 */
function getFormData() {
  const courseLength = parseFloat(document.getElementById('courseLength').value);
  const baseMidSpeed = parseFloat(document.getElementById('baseMidSpeed').value);
  const baseFinalSpeed = parseFloat(document.getElementById('baseFinalSpeed').value);
  const baseAccel = parseFloat(document.getElementById('baseAccel').value);
  const skillRate = parseFloat(document.getElementById('skillRate').value);
  const trials = parseInt(document.getElementById('trials').value, 10);

  const skillRows = document.querySelectorAll('#skillTableBody tr[data-idx]');
  const skills = [];
  skillRows.forEach((row) => {
    const name = row.querySelector('.skill-name').value.trim();
    const start = Number.parseFloat(row.querySelector('.skill-start').value || '0');
    const end = Number.parseFloat(row.querySelector('.skill-end').value || '0');
    const baseDuration = Number.parseFloat(row.querySelector('.skill-base-duration').value || '0');
    const topSpeedBonus = Number.parseFloat(row.querySelector('.skill-top-speed-bonus').value || '0');
    const accelBonus = Number.parseFloat(row.querySelector('.skill-accel-bonus').value || '0');
    const currentSpeedBonus = Number.parseFloat(row.querySelector('.skill-current-speed-bonus').value || '0');
    const individualRateRaw = row.querySelector('.skill-individual-rate').value;
    const individualRate = (individualRateRaw !== '' && individualRateRaw != null)
      ? Number.parseFloat(individualRateRaw)
      : null;
    const belongsToA = row.querySelector('.set-a').checked;
    const belongsToB = row.querySelector('.set-b').checked;

    if (!Number.isNaN(start) && !Number.isNaN(end)) {
      skills.push({
        name,
        start,
        end,
        baseDuration,
        topSpeedBonus,
        accelBonus,
        currentSpeedBonus,
        individualRate,
        belongsToA,
        belongsToB,
      });
    }
  });

  return {
    courseLength,
    baseMidSpeed,
    baseFinalSpeed,
    baseAccel,
    skillRate,
    trials,
    skills,
  };
}

/**
 * フォームデータを localStorage に保存
 */
function saveFormData() {
  const data = getFormData();
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}

/**
 * localStorage から読み込み
 */
function loadFormData() {
  const json = localStorage.getItem(STORAGE_KEY);
  if (!json) return;
  try {
    const data = JSON.parse(json);
    document.getElementById('courseLength').value = data.courseLength;
    document.getElementById('baseMidSpeed').value = data.baseMidSpeed;
    document.getElementById('baseFinalSpeed').value = data.baseFinalSpeed;
    document.getElementById('baseAccel').value = data.baseAccel;
    document.getElementById('skillRate').value = data.skillRate;
    document.getElementById('trials').value = data.trials;

    // スキルテーブルを再構築
    const skillBody = document.getElementById('skillTableBody');
    skillBody.querySelectorAll('tr[data-idx]').forEach((row) => row.remove());
    const addBtnRow = skillBody.querySelector('tr:not([data-idx])');

    data.skills?.forEach((sk, i) => {
      const newRow = document.createElement('tr');
      newRow.setAttribute('data-idx', `${i}`);
      newRow.innerHTML = `
        <td><input type="text" class="skill-name" value="${sk.name || ''}" /></td>
        <td><input type="number" class="skill-start" value="${sk.start}" step="0.01"/></td>
        <td><input type="number" class="skill-end" value="${sk.end}" step="0.01"/></td>
        <td><input type="number" class="skill-base-duration" value="${sk.baseDuration}" step="0.01"/></td>
        <td><input type="number" class="skill-top-speed-bonus" value="${sk.topSpeedBonus}" step="0.01"/></td>
        <td><input type="number" class="skill-accel-bonus" value="${sk.accelBonus}" step="0.01"/></td>
        <td><input type="number" class="skill-current-speed-bonus" value="${sk.currentSpeedBonus}" step="0.01"/></td>
        <td><input type="number" class="skill-individual-rate" value="${sk.individualRate || ''}" step="0.001"/></td>
        <td>
          <label><input type="checkbox" class="set-a" ${sk.belongsToA ? 'checked' : ''}>A</label>
          <label><input type="checkbox" class="set-b" ${sk.belongsToB ? 'checked' : ''}>B</label>
        </td>
        <td><button type="button" class="delete-row">削除</button></td>
      `;
      skillBody.insertBefore(newRow, addBtnRow);
    });
  } catch (err) {
    console.error('Failed to parse form data:', err);
  }
}

/**
 * スキル行を再構成する関数
 */
function reindexSkillRows() {
  const rows = document.querySelectorAll('#skillTableBody tr[data-idx]');
  rows.forEach((row, index) => {
    row.setAttribute('data-idx', index);
  });
}

/**
 * スキル行を削除する関数
 */
function deleteSkillRow(row) {
  row.remove(); // 行を削除
  reindexSkillRows(); // インデックスを再構成
  saveFormData(); // データを保存
}

/**
 * スキル行を追加する関数
 */
function addSkillRow() {
  const skillBody = document.getElementById('skillTableBody');
  const currentRows = skillBody.querySelectorAll('tr[data-idx]');
  const newIndex = currentRows.length;

  const newRow = document.createElement('tr');
  newRow.setAttribute('data-idx', `${newIndex}`);
  newRow.innerHTML = `
    <td><input type="text" class="skill-name" placeholder="スキル名" /></td>
    <td><input type="number" class="skill-start" step="0.01" value="0" /></td>
    <td><input type="number" class="skill-end" step="0.01" value="0" /></td>
    <td><input type="number" class="skill-base-duration" step="0.01" value="3" /></td>
    <td><input type="number" class="skill-top-speed-bonus" step="0.01" value="0" /></td>
    <td><input type="number" class="skill-accel-bonus" step="0.01" value="0" /></td>
    <td><input type="number" class="skill-current-speed-bonus" step="0.01" value="0" /></td>
    <td><input type="number" class="skill-individual-rate" step="0.001" /></td>
    <td>
      <label><input type="checkbox" class="set-a" checked>A</label>
      <label><input type="checkbox" class="set-b" checked>B</label>
    </td>
    <td><button type="button" class="delete-row">削除</button></td>
  `;

  // 追加ボタン行の直前に挿入
  const addBtnRow = skillBody.querySelector('tr:not([data-idx])');
  skillBody.insertBefore(newRow, addBtnRow);

  // 削除ボタンにイベントリスナーを追加
  const deleteButton = newRow.querySelector('.delete-row');
  deleteButton.addEventListener('click', () => deleteSkillRow(newRow));

  saveFormData();
}

// グローバルChartインスタンス
let chartInstance = null;

/**
 * A/B用のタイム差分布(ヒストグラム)と累積度数を計算して返すヘルパー
 */
function calcDiffDistribution(noSkillTime, trials, courseLength, baseMidSpeed, baseFinalSpeed, baseAccel, skillRate, skills) {
  // 多試行でタイム差を収集
  const diffArray = [];
  for (let i = 0; i < trials; i++) {
    const withSkillTime = runWithSkill(
      courseLength,
      baseMidSpeed,
      baseFinalSpeed,
      baseAccel,
      skillRate,
      skills
    );
    // diff = スキルなし - スキルあり (正ならスキルありのほうが速い)
    let diff = noSkillTime - withSkillTime;
    if (diff < 0) diff = 0; // 負値は0にクリップ
    diffArray.push(diff);
  }

  diffArray.sort((a, b) => a - b);
  const minVal = 0;
  const maxVal = diffArray[diffArray.length - 1] || 0;
  const binCount = 40;
  const binSize = (maxVal - minVal) / (binCount || 1);
  const bins = new Array(binCount).fill(0);

  diffArray.forEach((val) => {
    const index = Math.floor((val - minVal) / binSize);
    const safeIndex = (index === binCount) ? binCount - 1 : index;
    if (safeIndex >= 0 && safeIndex < binCount) {
      bins[safeIndex]++;
    }
  });

  // ヒストグラム折れ線用データ
  const histData = [];
  for (let i = 0; i < binCount; i++) {
    const xVal = minVal + (i + 0.5) * binSize;
    const freq = bins[i] / trials;
    histData.push({ x: xVal, y: freq });
  }

  // 累積データ
  const cumulativeData = [];
  let cumulativeSum = 0;
  for (let i = 0; i < binCount; i++) {
    cumulativeSum += bins[i] / trials; // 累積度数
    const xVal = minVal + (i + 0.5) * binSize;
    cumulativeData.push({ x: xVal, y: cumulativeSum });
  }

  return { histData, cumulativeData, diffArray };
}

/**
 * A/B を一つのテーブルにまとめて表示
 *   - 累積度数を 0.0～1.0 を 0.1 刻み (10 区間) で見て、
 *     その区間に含まれる秒数差 (x) の最大値を求め、テーブルに出力
 */
function buildCombinedRangeTable(distA, distB, baseFinalSpeed) {
  const tableBody = document.querySelector('#rangeTableCombined tbody');
  tableBody.innerHTML = ''; // いったんクリア

  // 0.0～1.0 を 0.1 刻みでループ
  for (let i = 0; i < 10; i++) {
    const rangeStart = i / 10;
    const rangeEnd = (i + 1) / 10;

    // A/B それぞれで、この累積度数範囲に入っている x(=差分秒) の最大値を求める
    const maxA = getMaxDiffInRange(distA.cumulativeData, rangeStart, rangeEnd);
    const maxB = getMaxDiffInRange(distB.cumulativeData, rangeStart, rangeEnd);

    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${rangeStart.toFixed(1)} - ${rangeEnd.toFixed(1)}</td>
      <td>${maxA.toFixed(2)}</td>
      <td>${(maxA * baseFinalSpeed).toFixed(2)}</td>
      <td>${maxB.toFixed(2)}</td>
      <td>${(maxB * baseFinalSpeed).toFixed(2)}</td>
    `;
    tableBody.appendChild(row);
  }

  /**
   * cumulativeData の中から、累積度数 (y) が [rangeStart, rangeEnd) に入る
   * x(=秒数差) の最大値を返す
   */
  function getMaxDiffInRange(cumulativeData, rangeStart, rangeEnd) {
    let maxVal = 0;
    cumulativeData.forEach(({ x, y }) => {
      if (y >= rangeStart && y < rangeEnd) {
        if (x > maxVal) {
          maxVal = x;
        }
      }
    });
    return maxVal;
  }
}

/**
 * メイン計算処理 (フォーム送信)
 */
function onSubmit(e) {
  e.preventDefault();
  saveFormData();

  // 入力データ取得
  const {
    courseLength,
    baseMidSpeed,
    baseFinalSpeed,
    baseAccel,
    skillRate,
    trials,
    skills,
  } = getFormData();

  // スキルなしタイムを一度だけ計算
  const noSkillTime = runNoSkill(courseLength, baseMidSpeed, baseFinalSpeed, baseAccel);

  // スキルセットAとBに含まれるスキルを抽出
  const skillsA = skills.filter(s => s.belongsToA);
  const skillsB = skills.filter(s => s.belongsToB);

  // A/B のタイム差分布を計算
  const distA = calcDiffDistribution(noSkillTime, trials, courseLength, baseMidSpeed, baseFinalSpeed, baseAccel, skillRate, skillsA);
  const distB = calcDiffDistribution(noSkillTime, trials, courseLength, baseMidSpeed, baseFinalSpeed, baseAccel, skillRate, skillsB);

  // A/B を行をそろえて一つのテーブルにまとめる
  buildCombinedRangeTable(distA, distB, baseFinalSpeed);

  // Chart.js 描画 (ヒストグラム & 累積)
  if (chartInstance) {
    chartInstance.destroy();
  }
  const ctx = document.getElementById('timeDiffChart').getContext('2d');

  chartInstance = new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [
        // A ヒストグラム (赤)
        {
          label: 'セットA: 相対度数(ヒストグラム)',
          data: distA.histData,
          backgroundColor: 'rgba(255, 99, 132, 0.2)',
          borderColor: 'rgba(255, 99, 132, 1)',
          fill: false,
          tension: 0.4,
          pointRadius: 0,
          yAxisID: 'y',
        },
        // A 累積 (赤・少し薄い)
        {
          label: 'セットA: 累積度数',
          data: distA.cumulativeData,
          backgroundColor: 'rgba(255, 99, 132, 0.1)',
          borderColor: 'rgba(255, 99, 132, 0.5)',
          fill: false,
          tension: 0.4,
          pointRadius: 0,
          yAxisID: 'y1',
        },
        // B ヒストグラム (青)
        {
          label: 'セットB: 相対度数(ヒストグラム)',
          data: distB.histData,
          backgroundColor: 'rgba(54, 162, 235, 0.2)',
          borderColor: 'rgba(54, 162, 235, 1)',
          fill: false,
          tension: 0.4,
          pointRadius: 0,
          yAxisID: 'y',
        },
        // B 累積 (青・少し薄い)
        {
          label: 'セットB: 累積度数',
          data: distB.cumulativeData,
          backgroundColor: 'rgba(54, 162, 235, 0.1)',
          borderColor: 'rgba(54, 162, 235, 0.5)',
          fill: false,
          tension: 0.4,
          pointRadius: 0,
          yAxisID: 'y1',
        },
      ],
    },
    options: {
      responsive: true,
      plugins: {
        legend: {
          display: true,
        },
      },
      scales: {
        x: {
          type: 'linear',
          title: {
            display: true,
            text: 'タイム差 (秒)',
          },
        },
        y: {
          type: 'linear',
          position: 'left',
          title: {
            display: true,
            text: '相対度数',
          },
          beginAtZero: true,
        },
        y1: {
          type: 'linear',
          position: 'right',
          title: {
            display: true,
            text: '累積度数',
          },
          beginAtZero: true,
        },
      },
    },
  });
}

document.addEventListener('DOMContentLoaded', () => {
  const form = document.getElementById('calc-form');
  const addBtn = document.getElementById('addSkillRow');

  // ロード
  loadFormData();

  // イベント
  form.addEventListener('submit', onSubmit);
  form.addEventListener('input', saveFormData);
  addBtn.addEventListener('click', () => {
    addSkillRow();
    saveFormData();
  });
  const skillRows = document.querySelectorAll('.delete-row');
  skillRows.forEach((btn) =>
    btn.addEventListener('click', () => deleteSkillRow(btn.closest('tr')))
  );
});
</script>
</body>
</html>
